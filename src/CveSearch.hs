{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
module CveSearch where

import Control.Monad ((<=<))
import Data.Monoid ((<>))
import Data.Aeson hiding (Result, json)
import Data.Map as M
import qualified Data.Text as T
import Database.Bolt
import GHC.Generics
import Debug.Trace

-- | Limit for cypher query results.
newtype Limit = Limit Int

-- | Skip for cypher query results.
newtype Skip = Skip Int

-- | Search query type.
data SearchQuery = SearchQuery
  { regex :: T.Text
  , responseFields :: [T.Text]
  , skip :: Int
  , limit :: Int
  , year :: Int
  } deriving (Eq, FromJSON, Generic, Show, ToJSON)

-- | Api return type.
newtype Result = Result
  { result :: [M.Map T.Text T.Text]
  } deriving (Eq, FromJSON, Generic, Show, ToJSON)

-- | Search CVE's in the given year by matching their summaries against a
-- regular expression. Paging via skip and limit params.
cveSearchBySummary :: Int -> Skip -> Limit -> T.Text -> BoltActionT IO Result
cveSearchBySummary year (Skip skip) (Limit limit) regex = do
  records <- queryP (traceShow (qSummaryByCveYear year) qSummaryByCveYear year) queryParams
  mapM (getSummaryAndId <=< toNode) records >>= pure . Result
 where
  queryParams = fromList
    [ ("text", T regex)
    , ("skip", I skip)
    , ("limit", I limit)
    ]
  getSummaryAndId :: Monad m => Node -> m (Map T.Text T.Text)
  getSummaryAndId node = pure $ M.fromList
    [ node `propsAtKey` "cveId"
    , node `propsAtKey` "summary"
    ]

-- | Query to search summaries of a given CVE.
qSummaryByCveYear :: Int -> T.Text
qSummaryByCveYear year =
  "MATCH (n:CVE:`"
    <> (T.pack . show $ year)
    <> "`) where n.summary =~ {text} RETURN n ORDER BY n.cveId DESC"
    <> " SKIP {skip} LIMIT {limit}"

-- | Transform a 'Record' into a 'Node'.
toNode :: Monad m => Record -> m Node
toNode r = r `at` "n" >>= exact

-- | Get the value of the node properties at the given key, returning
-- a tuple of the key and the value.
propsAtKey :: Node -> T.Text -> (T.Text, T.Text)
propsAtKey node key = exact (nodeProps node ! key) >>= (,) key
