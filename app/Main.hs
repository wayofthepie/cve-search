{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Main where

import Control.Monad ((<=<))
import Data.Aeson hiding (Result, json)
import Data.Default
import Data.Map as M
import qualified Data.Text as T
import Database.Bolt
import GHC.Generics
import Web.Spock hiding (head)
import Web.Spock.Config
import Debug.Trace

-- | Search query type.
data SearchQuery = SearchQuery
  { regex :: T.Text
  , responseFields :: [T.Text]
  } deriving (Eq, FromJSON, Generic, Show, ToJSON)

-- | Api return type.
newtype Result = Result
  { result :: [M.Map T.Text T.Text]
  } deriving (Eq, FromJSON, Generic, Show, ToJSON)

main :: IO ()
main  = do
  spockCfg <- defaultSpockCfg () (PCConn neoConnBuilder) ()
  runSpock 8080 (spock spockCfg app)

-- | Neo4j connection builder.
neoConnBuilder :: ConnBuilder Pipe
neoConnBuilder = ConnBuilder
  { cb_createConn = connect conf
  , cb_destroyConn = close
  , cb_poolConfiguration = neoPoolConf
  }

-- | Neo4j connection pool configuration.
neoPoolConf :: PoolCfg
neoPoolConf = PoolCfg
  { pc_stripes = 2
  , pc_resPerStripe = 2
  , pc_keepOpenTime = 10
  }

-- | Default bolt credentials for our test instance.
conf :: BoltCfg
conf = def { user = "neo4j", password = "test" }

-- | Routes that define our app.
app :: SpockM Pipe () () ()
app = do
  get root $ text "Hello World!"
  get ("/cve/summary/search" <//> var) $ \summaryContents ->
    runQuery (\pipe -> run pipe $ querySearch summaryContents) >>= json

-- | Basic regex search on summaries.
querySearch :: T.Text -> BoltActionT IO Result
querySearch regex = do
  records <- queryP cypher (fromList [("text", T regex)])
  mapM (getSummaryAndId <=< toNode) records >>= pure . Result
 where
  cypher :: T.Text
  cypher = "MATCH (n:CVE) where n.summary =~ {text} RETURN n"

  atKey :: Monad m => Node -> T.Text -> m (T.Text, T.Text)
  atKey node key = do
    propVal <- exact (nodeProps node ! key)
    pure (key, propVal)

  getSummaryAndId :: Monad m => Node -> m (Map T.Text T.Text)
  getSummaryAndId node = do
    cveId <- node `atKey` "cveId"
    summary <- node `atKey` "summary"
    pure $ M.fromList [cveId, summary]

-- | Transform a 'Record' into a 'Node'.
toNode :: Monad m => Record -> m Node
toNode r = r `at` "n" >>= exact
